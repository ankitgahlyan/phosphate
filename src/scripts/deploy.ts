//  SPDX-License-Identifier: MIT
//  Copyright ¬© 2025 TON Studio

import {
    beginCell,
    toNano,
    TonClient,
    WalletContractV4,
    SendMode,
    internal,
    fromNano,
} from "@ton/ton"
import {getHttpEndpoint} from "@orbs-network/ton-access"
import {mnemonicToPrivateKey} from "@ton/crypto"
import {buildJettonMinterFromEnv} from "../utils/jetton-helpers"
import {storeMint} from "../output/Root_JettonMinterSharded"

import {printSeparator} from "../utils/print"
import "dotenv/config"
import {getJettonHttpLink, getNetworkFromEnv} from "../utils/utils"

const main = async () => {
    const mnemonics = process.env.MNEMONICS
    if (mnemonics === undefined) {
        console.error("Mnemonics is not provided, please add it to .env file")
        throw new Error("Mnemonics is not provided")
    }
    if (mnemonics.split(" ").length !== 24) {
        console.error("Invalid mnemonics, it should be 24 words")
        throw new Error("Invalid mnemonics, it should be 24 words")
    }

    const network = getNetworkFromEnv()

    const endpoint = await getHttpEndpoint({network})
    const client = new TonClient({
        endpoint: endpoint,
    })
    const keyPair = await mnemonicToPrivateKey(mnemonics.split(" "))
    const secretKey = keyPair.secretKey
    const workchain = 0 // we are working in basechain.
    const deployerWallet = WalletContractV4.create({
        workchain: workchain,
        publicKey: keyPair.publicKey,
    })

    const deployerWalletContract = client.open(deployerWallet)
    const jettonMinter = await buildJettonMinterFromEnv(deployerWalletContract.address)
    const deployAmount = toNano("1.5")

    const supply = toNano(Number(process.env.JETTON_SUPPLY ?? 1000000000)) // 1_000_000_000 jettons
    // const supply = toNano(parseFloat("0.1"))
    const packed_msg = beginCell()
        .store(
            storeMint({
                $$type: "Mint",
                queryId: 0n,
                mintMessage: {
                    $$type: "JettonTransferInternal",
                    amount: supply,
                    version: 0n,
                    currentCode: null,
                    sender: deployerWalletContract.address,
                    responseDestination: deployerWalletContract.address,
                    queryId: 0n,
                    forwardTonAmount: 0n,
                    forwardPayload: beginCell().storeUint(0, 1).asSlice(),
                },
                receiver: deployerWalletContract.address,
            }),
        )
        .endCell()

    // const packed_msg = beginCell()
    //     .store(
    //         storeInviteInternal({
    //             $$type: "InviteInternal",
    //             amount: supply,
    //             sender: deployerWalletContract.address,
    //             invitor: deployerWalletContract.address,
    //             forwardPayload: beginCell().endCell().asSlice(),
    //         }),
    //     ).endCell()

    // send a message on new address contract to deploy it
    const seqno: number = await deployerWalletContract.getSeqno()
    console.log(`Running deploy script for ${network} network and for Shard Jetton Minter`)
    console.log(
        "üõ†Ô∏èPreparing new outgoing massage from deployment wallet. \n" +
            deployerWalletContract.address,
    )
    console.log("Seqno: ", seqno + "\n")
    printSeparator()

    // Get deployment wallet balance
    const balance: bigint = await deployerWalletContract.getBalance()

    console.log("Current deployment wallet balance = ", fromNano(balance).toString(), "üíéTON")
    if (balance < deployAmount) {
        console.error("Not enough balance to deploy the contract")
        throw new Error("Not enough balance to deploy the contract")
    }

    console.log("Minting:: ", fromNano(supply))
    printSeparator()

    // deploy master + wallet by sending mint msg
    await deployerWalletContract.sendTransfer({
        seqno,
        secretKey,
        sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
        messages: [
            internal({
                to: jettonMinter!.address,
                value: deployAmount,
                body: packed_msg,
                init: {
                    code: jettonMinter!.init?.code,
                    data: jettonMinter!.init?.data,
                },
                // to: 'EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N',
                //   body: 'Example transfer body',
            }),
        ],
    })

    console.log("====== Deployment message sent to =======\n", jettonMinter!.address)
    try {
        const fs = await import("fs/promises")
        const outFile = `${process.cwd()}/src/scripts/consts.ts`
        const address = jettonMinter!.address.toString()
        const content = `// Auto-generated by shard.deploy.ts\nexport const ROOT_ADDRESS = "${address}"\n`
        await fs.writeFile(outFile, content, "utf8")
        console.log("Saved minter address const to", outFile)
    } catch (err) {
        console.warn("Failed to save minter address:", err)
    }
    const link = getJettonHttpLink(network, jettonMinter!.address, "tonviewer")
    console.log(`You can soon check your deployed contract at ${link}`)
}

void main()
